# 第7章 面向对象编程（基础部分）
## 7.1 类与对象
* 数组处理问题：
  * 数据类型体现不出来
  * 只能通过[下标]获取信息，造成变量名字和内容的对应关系不明确
  * 不能体现猫的行为
* 类与对象的区别
  1) 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型. 
  2) 对象是具体的，实际的，代表一个具体事物, 即 是实例.
  3) 类是对象的模板，对象是类的一个个体，对应一个实例
* 对象在内存中存在形式(重要的)必须搞清楚

## 7.4 方法递归调用（非常非常重要）
* 递归就是方法自己调用自己。
* 递归重要规则
  1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）。
  2. 每一个栈都会完整的执行方法，在哪里调用就在哪里返回。
  3. 递归必须向退出递归的条件逼近，否则就是无限递归。
  4. 方法的局部变量是独立的，不会相互影响。
  5. 如果方法中使用的是引用类型变量（比如数组，对象），就会共享该引用类型的数据。
  6. 当一个方法执行完毕，或者遇到`return`，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法就执行完毕。
* 重要的知道在调用递归时的内存情况，可以画图进行分析：
  * [打印与阶乘问题](Recursion01.java)   
  * [斐波那契数与猴子吃桃子问题](RecursionExercise01.java)
* 用递归的思想解决一些实际问题：
  * [迷宫问题](MiGong.java)
  * [汉诺塔](HanoiTower.java)
  * [八皇后问题](EightQueens.java)(代码需要更新，还有错误，未完成)

## 7.5 方法重载
* java中允许同一个类中，多个同名方法的存在，但要求**形参列表**不一致!
* 注意事项及细节：
  1. 方法名：必须相同
  2. 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求）
  3. **返回类型：无要求**
* [方法重载练习代码](OverLoadExercise.java)

## 7.6 可变参数
* Java允许将**同一个类中多个同名同功能但参数个数不同的方法**，封装成一个方法，通过可变参数实现。
* 基本语法：
```
访问修饰符 返回类型 方法名(数据类型... 形参名){
  方法体
}
```
* 可变参数实例:[计算多个数的和](VarParameter01.java)
* 注意事项和细节：
  1. 可变参数的实参可以为0个或任意多个；
  2. 可变参数的实参可以为数组；
  3. 可变参数的本质就是数组；
  4. **可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后**；
  5. 一个形参列表只能出现一个可变参数。
* [可变参数练习代码](VarParameterExercise.java)：有三个方法，分别实现返回姓名和两门课成绩(总分)， 返回姓名和三门课成绩(总分)，返回姓名和五门课成绩(总分)。 封装成一个可变参数的方法。

## 7.7 作用域
* 在java编程中，主要的变量就是属性（成员变量）和局部变量。
* 我们说的局部变量一般是指在成员方法中定义的变量。
* java中作用域的分类：
  * 全局变量：也就是属性，作用域为整个类体。
  * 局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！
* **全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。**
* 注意事项和细节使用（**这些规则需要记住**）
  1. 属性和局部变量可以重名，访问时遵循就近原则。
  2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
  3. **属性生命周期较长**，伴随着对象的创建而创建，伴随着对象的销毁而销毁。**局部变量生命周期较短**，伴随着它的代码块执行而创建，伴随着代码块的结束而销毁，即在一次方法调用过程中。
  4. 作用域范围不同
     * 全局变量/属性：可以被本类使用，或其他类使用（通过对象调用）
     * 局部变量：只能在本类中对应的方法中使用
  5. 修饰符不同
     * 全局变量/属性可以加修饰符
     * **局部变量不可以加修饰符**  

## 7.8 构造方法/构造器
* 基本语法
```
[修饰符] 方法名(形参列表){ 
  方法体;
}
```
* 说明：
  1) 构造器的修饰符可以默认，也可以是public、protected、private 
  2) **构造器没有返回值**
  3) **方法名和类名字必须一样**
  4) 参数列表和成员方法一样的规则
  5) 构造器的调用, 由系统完成
* 构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是**完成对新对象的初始化**。它有几个特点:
  1) 方法名和类名相同
  2) 没有返回值
  3) 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。
* 注意事项和使用细节([构造器实例代码](ConstructorDetail.java))
  1. 一个类可以定义多个不同的构造器，即构造器重载
  2. 构造器名和类名要相同
  3. 构造器没有返回值
  4. 构造器是完成对象的初始化，并不是创建对象
  5. 在创建对象时，系统自动的调用该类的构造方法
  6. 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器），比如`Dog(){}`，可以使用`javap`指令反编译查看
  7. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下，即`Dog(){}`。（**这点很重要**） 
* [构造器练习代码](ConstructorExercise.java)：
  * 在前面定义的 Person 类中添加两个构造器: 第一个无参构造器:利用构造器设置所有人的 age 属性初始值都为18。
  * 第二个带pName和pAge两个参数的构造器:使得每次创建Person对象的同时初始化对象的age属性值和name属性值。 
  * 分别使用不同的构造器，创建对象。

## 7.9 对象创建的流程分析
```java
class Person{//类Person
  int age = 90;
  String name;
  Person(String n, int a) {//构造器
    name = n;//给属性赋值
    age = a;//...
  }
}
Person p = new Person("小倩",20);
```
* **流程分析**（面试题）
  1.  加载`Person`类信息（`Person.class`），只会加载一次
  2.  在堆中分配空间（地址）
  3.  完成对象初始化
      1.  默认初始化`age = 0, name = null`
      2.  显式初始化`age = 90, name = null`
      3.  构造器初始化`age = 20, name = 小倩`
  4. 把对象在堆中的地址返回给p（p是对象名，也可以理解成是对象的引用）